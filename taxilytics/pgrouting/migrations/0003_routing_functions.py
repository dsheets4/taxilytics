# -*- coding: utf-8 -*-
# Generated by Django 1.10.3 on 2017-08-29 22:34
from __future__ import unicode_literals

from django.db import migrations

from pgrouting import loader


class Migration(migrations.Migration):

    dependencies = [
        ('pgrouting', '0002_load_database'),
    ]

    operations = [
        migrations.RunSQL(
            sql="""
                CREATE TYPE traj_RoadMatchRecord as (
                    gid bigint,
                    class_id integer,
                    length double precision,
                    length_m double precision,
                    name text,
                    source bigint,
                    target bigint,
                    x1 double precision,
                    y1 double precision,
                    x2 double precision,
                    y2 double precision,
                    cost double precision,
                    reverse_cost double precision,
                    cost_s double precision,
                    reverse_cost_s double precision,
                    rule text,
                    one_way integer,
                    maxspeed_forward integer,
                    maxspeed_backward integer,
                    osm_id bigint,
                    source_osm bigint,
                    target_osm bigint,
                    priority double precision,
                    the_geom geometry
                    ,point geometry
                    ,seg_length double precision
                    ,dist double precision
                    ,road_seg_hdg double precision
                );
            """,
            reverse_sql="""DROP TYPE traj_RoadMatchRecord;"""
        ),
        migrations.RunSQL(
            sql="""
                CREATE OR REPLACE FUNCTION traj_RoadMatchPoint(data_to_match geometry, segment_length double precision DEFAULT 0.001)
                  RETURNS SETOF traj_RoadMatchRecord AS
                $BODY$
                DECLARE
                BEGIN
                    RETURN QUERY WITH candidates AS (
                        SELECT *
                        FROM ways as n
                        ORDER BY n.the_geom <#> data_to_match
                        LIMIT 10
                    )
                    SELECT
                        *
                        , data_to_match
                        , segment_length
                        , ST_Distance(c.the_geom, data_to_match) as dist
                        , degrees(ST_Azimuth( -- Calculates the north heading of the road segment nearest the query point.
                            ST_LineInterpolatePoint(the_geom, GREATEST(ST_LineLocatePoint(the_geom, data_to_match)-segment_length, CAST(0 AS FLOAT))),
                            ST_LineInterpolatePoint(the_geom, LEAST(ST_LineLocatePoint(the_geom, data_to_match)+segment_length, CAST(1 AS FLOAT)))
                        )) as road_seg_hdg
                    FROM candidates AS c
                    ORDER BY ST_Distance(c.the_geom, data_to_match)
                    LIMIT 1;
                END
                $BODY$
                LANGUAGE plpgsql VOLATILE;
            """,
            reverse_sql="""DROP FUNCTION traj_RoadMatchPoint(geometry, double precision)"""
        ),
        migrations.RunSQL(
            sql="""
                CREATE OR REPLACE FUNCTION traj_RoadMatchCollection(data_to_match geometry, segment_length double precision DEFAULT 0.001)
                  RETURNS SETOF traj_RoadMatchRecord AS
                $BODY$
                DECLARE
                    g geometry;
                BEGIN
                    FOR g IN
                        SELECT geom FROM ST_Dump(data_to_match)
                    LOOP
                        RETURN NEXT traj_RoadMatchPoint(g, segment_length);
                    END LOOP;
                END
                $BODY$
                LANGUAGE plpgsql VOLATILE;
            """,
            reverse_sql="""DROP FUNCTION traj_RoadMatchCollection(geometry, double precision)"""
        ),
        migrations.RunSQL(
            sql="""
                CREATE OR REPLACE FUNCTION traj_RoadMatchLinestring(data_to_match geometry, segment_length double precision DEFAULT 0.001)
                  RETURNS SETOF traj_RoadMatchRecord AS
                $BODY$
                DECLARE
                    g geometry;
                BEGIN
                    FOR g IN
                        SELECT geom FROM ST_DumpPoints(data_to_match)
                    LOOP
                        RETURN NEXT traj_RoadMatchPoint(g, segment_length);
                    END LOOP;
                END
                $BODY$
                LANGUAGE plpgsql VOLATILE;
            """,
            reverse_sql="""DROP FUNCTION traj_RoadMatchLinestring(geometry, double precision)"""
        ),
        migrations.RunSQL(
            sql="""
                CREATE OR REPLACE FUNCTION traj_RoadMatch(data_to_match geometry, segment_length double precision DEFAULT 0.001)
                  RETURNS SETOF traj_RoadMatchRecord AS
                $BODY$
                DECLARE
                BEGIN
                    IF ST_IsCollection(data_to_match) THEN
                        RETURN QUERY SELECT * FROM traj_RoadMatchCollection(data_to_match, segment_length);
                    ELSIF ST_GeometryType(data_to_match) = 'ST_LineString' THEN  -- Could also support Polygon but does that make sense?
                        RETURN QUERY SELECT * FROM traj_RoadMatchLinestring(data_to_match, segment_length);
                    ELSE
                        RETURN QUERY SELECT * FROM traj_RoadMatchPoint(data_to_match, segment_length);
                    END IF;
                END
                $BODY$
                LANGUAGE plpgsql VOLATILE;
            """,
            reverse_sql="""DROP FUNCTION traj_RoadMatch(geometry, double precision);"""
        ),
        migrations.RunSQL(
            sql="""
                CREATE OR REPLACE FUNCTION traj_Route(src integer, tgt integer, within double precision DEFAULT 0.01)
                  RETURNS SETOF pgr_costresult AS
                $BODY$
                DECLARE
                    bbox geometry;
                    s integer;
                    t integer;
                BEGIN
                    WITH endpoints AS (
                        SELECT the_geom FROM ways WHERE gid=src OR gid=tgt
                    )
                    SELECT ST_Extent(the_geom) INTO bbox FROM endpoints;

                    SELECT source INTO s FROM ways WHERE gid=src;
                    SELECT target INTO t FROM ways WHERE gid=tgt;

                    RAISE NOTICE 'source(%)', s;
                    RAISE NOTICE 'target(%)', t;

                    RETURN QUERY SELECT * FROM pgr_astar(
                        concat('
                            SELECT
                                gid as id,
                                source::int4,
                                target::int4,
                                cost,
                                x1, y1, x2, y2,
                                reverse_cost
                            FROM ways
                            WHERE ST_DWithin(ST_GeomFromText(''',
                            ST_AsText(bbox),
                            ''', 4326), the_geom,', .01, ')'
                        ),  -- sql text,
                        s, -- source node ID,
                        t, -- target node ID,
                        true,  -- directed boolean,
                        false   -- has_rcost boolean
                    );
                END
                $BODY$
                LANGUAGE plpgsql VOLATILE;
            """,
            reverse_sql="""
                DROP FUNCTION traj_Route(integer, integer, double precision);
            """
        ),
    ]
